{
    "contents" : "findCoordinates = function (width, height){\n  .Call(\"findCoordinates\", width, height, PACKAGE = \"GOsummaries\")\n}\n\nfindCoordinates_left = function (width, height){\n  .Call(\"findCoordinates_left\", width, height, PACKAGE = \"GOsummaries\")\n}\n\nfindCoordinates_left_top = function (width, height){\n  .Call(\"findCoordinates_left_top\", width, height, PACKAGE = \"GOsummaries\")\n}\n\n#' Plot a wordcloud given words and frequencies\n#' \n#' General \\code{grid} based wordcloud drawing function \n#' \n#' Uses the algorithm from wordcloud package to calculate the positions of the words. \n#' then uses grid graphics to plot the words on screen. The shape of the wordcloud \n#' depends on the shape of the plotting window\n#'\n#' @param words vector of words to draw\n#' @param freq frequencies for words, has to be the same length as words vector\n#' @param rot.per percentage of vertical words\n#' @param max_min relative scales to adjust the size difference between largest and \n#' smallest word, by default the largest word is written with 10 times as large font than \n#' the smallest\n#' @param scale a fraction of the available space on figure that will be covered with the bounding boxes of words\n#' @param min.freq minimal frequency of words to be displayed\n#' @param max.words maximal number of words to be displayed\n#' @param random.order plot words in random order. If false, they will be plotted in\n#'  decreasing frequency\n#' @param colors vector of colors fro the words. This vector will be extrapolated into as \n#' many colors as needed, starting with the first color for lower frequencies and ending \n#' with last color for higher frequencies.\n#' @param random.colors if true, assigns random color for the words.\n#' @param algorithm algorithm to find positions of words possible values: \"circle\", \"leftside\" and \"rightside\".\n#' @param tryfit if TRUE the algorithm checks if all words fit to the figure, if not it\n#' tries gradually smaller values of scale parameter until everything fits\n#' @param add if TRUE adds the picture to existing plot.\n#' @param grob if TRUE returns the text grob instead of drawing it\n#' @param dimensions a two element vector of units giving the width and height of the word \n#' cloud respectively\n#' \n#' @author  Raivo Kolde <rkolde@@gmail.com>\n#' @examples\n#'  plotWordcloud(c(\"Audi\", \"Volkswagen\", \"Opel\", \"Porsche\", \"Mercedez\", \"BMW\"), 8:3)\n#' \n#' @export\nplotWordcloud = function(words, freq, rot.per = 0.3, max_min = c(1, 0.1), scale = 0.4, min.freq = 3, max.words = Inf, random.order = FALSE, colors = \"black\", random.colors = FALSE, algorithm = \"circle\", tryfit = T, add = F, grob = F, dimensions = unit(c(1, 1), \"npc\")){\n  # Empty the drawng area\n  if(!add){\n    grid.newpage()\n  }\n  \n  width = convertWidth(dimensions[1], \"cm\", valueOnly = T)\n  height = convertHeight(dimensions[2], \"cm\", valueOnly = T)\n  \n  # Check if word and freq are same length\n  if(length(words) != length(freq)){\n    stop(\"The word and freq length do not match\")\n  }\n  \n  # Create the data frame for words\n  d = data.frame(words, freq)\n  \n  # Create colors\n  if(length(colors) == 1){\n    d$colors = colors\n  }\n  else if(random.colors){\n    d$colors = sample(colorRampPalette(rev(colors))(nrow(d)))\n  }\n  else if(length(colors) == nrow(d)){\n    d$colors = colors\n  }\n  else{\n    d$colors = rep(colorRampPalette(rev(colors))(length(unique(d$freq))), table(d$freq))\n  }\n  \n  # Order words according to frequencies\n  ord = order(-d$freq)\n  d = d[ord, ]\n  \n  # Filter the words and frequencies\n  d = d[1:nrow(d) <= max.words, ]\n  d = d[d$freq >= min.freq, ]\n  \n  # Randomize order\n  if(random.order){\n    d = d[sample(1:nrow(d)), ]\n  }\n  \n  # Normalize the text sizes\n  d$words = as.character(d$words)\n  normedFreq <- d$freq/max(d$freq)\n  d$size <- (max_min[1]-max_min[2])*normedFreq + max_min[2]\n  \n  # Decide angle\n  n = nrow(d)\n  d$angle = ifelse(runif(n) < rot.per, 90, 0)\n  \n  # Calculate the word sizes\n  w = unit(rep(1, n), \"strwidth\", as.list(as.character(d$words)))\n  d$width = convertWidth(w, \"cm\", valueOnly = T) / width\n  h = unit(rep(1, n), \"strheight\", as.list(as.character(d$words)))\n  d$height = convertHeight(h, \"cm\", valueOnly = T) / height\n  \n  tailed = grepl(\"g|j|p|q|y|_\", d$words)\n  d$height[tailed] = d$height[tailed] * 1.3\n  \n  # Add padding \n  d$width = d$width * 1.1\n  d$height = d$height * 1.1\n  \n  # Rotate words\n  if(any(d$angle == 90)){\n    a = d$width[d$angle == 90]\n    d$width[d$angle == 90] = d$height[d$angle == 90] * height / width\n    d$height[d$angle == 90] = a * width / height\n  }\n  \n  # Calculate area of all words and apply scaling factor to sizes\n  area = sum(d$height * d$width * d$size ** 2)\n  d$size = d$size / sqrt(area / scale)\n  \n  # If some words are bigger than window scale down all words to fit there\n  maxsize = max(c(d$height * d$size, d$width * d$size))\n  if(maxsize > 1){\n    d$size = d$size / maxsize * 0.8\n  }\n  \n  # Resize the words\n  d$width = d$width * d$size\n  d$height = d$height * d$size\n  # d = d[d$size > 0.6,]\n  \n  \n  # Calculate the coordinates of words\n  if(tryfit) {\n    dontfit = T\n    while(dontfit){\n      if(algorithm == \"leftside\"){\n        a = findCoordinates_left(d$width, d$height)\n      }\n      if(algorithm == \"rightside\"){\n        a = findCoordinates_left(d$width, d$height)\n        a[, 1] = 1 - a[, 1]\n      }\n      if(algorithm == \"leftside_top\"){\n        a = findCoordinates_left_top(d$width, d$height)\n      }\n      if(algorithm == \"rightside_top\"){\n        a = findCoordinates_left_top(d$width, d$height)\n        a[, 1] = 1 - a[, 1]\n      }\n      if(algorithm == \"circle\"){\n        a = findCoordinates(d$width, d$height)\n      }\n      \n      if(any(a[, 2] == 3)){\n        d$size = d$size * 0.95\n        d$width = d$width * 0.95\n        d$height = d$height * 0.95\n        # d = d[d$size > 0.6,]\n      }\n      else{\n        dontfit = F\n      }\n    }\t\n  }\n  else{\n    if(algorithm == \"leftside\"){\n      a = findCoordinates_left(d$width, d$height)\n    }\n    if(algorithm == \"rightside\"){\n      a = findCoordinates_left(d$width, d$height)\n      a[, 1] = 1 - a[, 1]\n    }\n    if(algorithm == \"leftside_top\"){\n      a = findCoordinates_left_top(d$width, d$height)\n    }\n    if(algorithm == \"rightside_top\"){\n      a = findCoordinates_left_top(d$width, d$height)\n      a[, 1] = 1 - a[, 1]\n    }\n    if(algorithm == \"circle\"){\n      a = findCoordinates(d$width, d$height)\n    }\n  }\n  \n  d$x = a[, 1]\n  d$y = a[, 2]\n  \n  # Issue warning when something is not drawn\n  if(any(d$y == 3)){\n    warning(sprintf(\"Words not drawn: %s\", paste(as.character(d$words[d$y == 3]), collapse = \", \")))\n  }\n  \n  d = d[!(d$y == 3), ]\n  \n  if(nrow(d) < 1){\n    warning(\"No words to be drawn. Try adjusting scales if some of them did not fit.\")\n    return()\n  }\n  \n  # Shift the talied words upwards\n  tailed = grepl(\"g|j|p|q|y|_\", d$words)\n  if(any(d$angle == 90)){\n    if(algorithm == \"circle\"){\n      d[tailed & d$angle == 90, \"x\"] = d[tailed & d$angle == 90, \"x\"] - 0.1153846 * d[tailed & d$angle == 90, \"width\"]\n    }\n  }\n  d[tailed & d$angle == 0, \"y\"] = d[tailed & d$angle == 0, \"y\"] + 0.1153846 * d[tailed & d$angle == 0, \"height\"]\n  \n  \n  # Draw the words\n  if(algorithm %in% c(\"leftside\", \"leftside_top\")){\n    hjust = ifelse(d$angle == 90, 0.5, 0)\n    vjust = ifelse(d$angle == 90, 1, 0.5)\n  }\n  if(algorithm %in% c(\"rightside\", \"rightside_top\")){\n    hjust = ifelse(d$angle == 90, 0.5, 1)\n    vjust = ifelse(d$angle == 90, 0, 0.5)\n  }\n  if(algorithm == \"circle\"){\n    hjust = 0.5\n    vjust = 0.5\n  }\n  if(grob){\n    return(textGrob(d$words, d$x, d$y, rot = d$angle, hjust = hjust, vjust = vjust, gp = gpar(cex = d$size, col = d$colors), vp = viewport(width = unit(width, \"cm\"), height = unit(height, \"cm\"))))\n  }\n  else{\n    grid.text(d$words, d$x, d$y, rot = d$angle, hjust = hjust, vjust = vjust, gp = gpar(cex = d$size, col = d$colors), vp = viewport(width = unit(width, \"cm\"), height = unit(height, \"cm\")))\n  }\n  \n}",
    "created" : 1410196475268.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1500785124",
    "id" : "42F9C4D6",
    "lastKnownWriteTime" : 1410196855,
    "path" : "D:/Business/SameAndGregVenture/WeddingWordCloud/CloudUtilsAdv.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}